<!DOCTYPE html>
<html>
<head>
    <title>CSS3D Mixed Scene</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        CSS3D + WebGL Mixed Rendering<br>
        Drag to rotate â€¢ Scroll to zoom<br>
        The inner iframe is fully interactive!
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

        let camera, scene, rendererCSS3D, rendererWebGL;
        let controls;
        let cube, css3DObject;

        init();
        animate();

        function init() {
            // Container for controls
            const controlsContainer = document.createElement('div');
            controlsContainer.style.position = 'absolute';
            controlsContainer.style.top = '0';
            controlsContainer.style.width = '100%';
            controlsContainer.style.height = '100%';
            document.body.appendChild(controlsContainer);

            // CSS3D renderer (base layer)
            rendererCSS3D = new CSS3DRenderer();
            rendererCSS3D.setSize(window.innerWidth, window.innerHeight);
            rendererCSS3D.domElement.style.position = 'absolute';
            rendererCSS3D.domElement.style.top = '0';
            document.body.appendChild(rendererCSS3D.domElement);

            // WebGL renderer (top layer, transparent)
            rendererWebGL = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true 
            });
            rendererWebGL.domElement.style.position = 'absolute';
            rendererWebGL.domElement.style.top = '0';
            rendererWebGL.domElement.style.pointerEvents = 'none';
            rendererWebGL.setPixelRatio(window.devicePixelRatio);
            rendererWebGL.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(rendererWebGL.domElement);

            // Camera
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                1,
                5000
            );
            camera.position.set(0, 0, 1000);

            // Scene (shared by both renderers)
            scene = new THREE.Scene();

            // Controls
            controls = new OrbitControls(camera, controlsContainer);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting for WebGL
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Create frame/cube in WebGL
            const frameGroup = new THREE.Group();
            
            // Frame
            const frameGeometry = new THREE.BoxGeometry(820, 620, 40);
            const frameMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff41,
                emissive: 0x00ff41,
                emissiveIntensity: 0.2
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frameGroup.add(frame);
            
            // Inner black screen
            const screenGeometry = new THREE.PlaneGeometry(800, 600);
            const screenMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                opacity: 0.5,
                transparent: true
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 21;
            frameGroup.add(screen);
            
            scene.add(frameGroup);
            
            // Create invisible plane for CSS3D occlusion
            const planeGeometry = new THREE.PlaneGeometry(800, 600);
            const planeMaterial = new THREE.MeshBasicMaterial({
                opacity: 0,
                color: 0x000000,
                blending: THREE.NoBlending,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            scene.add(plane);

            // Create iframe and CSS3D object
            const iframe = document.createElement('iframe');
            iframe.style.width = '800px';
            iframe.style.height = '600px';
            iframe.style.border = '0px';
            iframe.style.backfaceVisibility = 'hidden';
            iframe.src = '/mini-scene.html'; // Your mini Three.js scene
            
            css3DObject = new CSS3DObject(iframe);
            css3DObject.position.set(0, 0, 0);
            scene.add(css3DObject);

            // Disable iframe interaction while rotating
            controls.addEventListener('start', () => {
                iframe.style.pointerEvents = 'none';
            });
            controls.addEventListener('end', () => {
                iframe.style.pointerEvents = 'auto';
            });

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            rendererWebGL.setSize(window.innerWidth, window.innerHeight);
            rendererCSS3D.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            // Render both in sync
            rendererCSS3D.render(scene, camera);
            rendererWebGL.render(scene, camera);
        }
    </script>
</body>
</html>